version: '3.8'

# This Docker Compose file sets up a secure microservices architecture.
# The 'nginx' service acts as the single entry point (reverse proxy).
# All other services have their ports removed, so they are not directly
# accessible from the public internet.

# services running on different ports  ..let's list down
# 1. Nginx Reverse Proxy (Public Facing)
# 2. Frontend (Landing Page Service) - Port 8080 internally
# 3. DB API (Database Service) - Port 5004 internally
# 4. Auth API (Authentication Service) - Port 5002 internally
# 5. Event Service - Port 5000 internally
# 6. User Portal Service - Port 5001 internally
# 7. Participation Service - Port 5005 internally
# 8. ERS Service - Port 5007 internally
# 9. Admin Portal Service - Port 5006 internally


services:
  # 1. The Nginx Reverse Proxy (Public Facing)
  nginx:
    build: ./nginx
    container_name: nginx_reverse_proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
      # NEW: Volumes for Certbot challenge files and Let's Encrypt certificates
      - certbot-web:/var/www/certbot # Volume for Certbot HTTP-01 challenges
      - certbot-certs:/etc/letsencrypt # Volume for Certbot certificates
      # Removed ./certs:/etc/nginx/certs as Certbot manages /etc/letsencrypt
    depends_on:
      - frontend
      - db_api
      - auth_api
      - event-service
      - user-portal-service
      - participation-service
    networks:
      - app-network

  # === NEW: Certbot Service ===
  certbot:
    image: certbot/certbot
    container_name: certbot_container
    # These volumes must match those in the Nginx service.
    volumes:
      - certbot-web:/var/www/certbot # Shared with Nginx for challenges
      - certbot-certs:/etc/letsencrypt # Shared with Nginx for certificates
    # Certbot needs Nginx to be running to verify domain ownership
    depends_on:
      - nginx 
    # The command to obtain initial certificates.
    # IMPORTANT: Replace YOUR_EMAIL@EXAMPLE.COM with your actual email.
    #            Replace ${HOST_IP_OR_DOMAIN} with your actual domain(s) from .env file.
    #            --staging is for testing. REMOVE IT for production certificates!
    command: certbot certonly --webroot -w /var/www/certbot --email Nest.alpine.cultural.team@gmail.com --agree-tos --no-eff-email -d ${HOST_IP_OR_DOMAIN} --staging
    # Note: For automatic renewal, this 'command' will be modified later (e.g., to run a cron job inside).
    networks:
      - app-network
    # Do NOT expose ports for certbot, it talks to Nginx internally

  # --- Backend and Frontend Services (Internal Only) ---

  frontend: # This is your Landing Page Service
    build:
      context: ./Frontend
    container_name: frontend_container
    restart: unless-stopped
    environment:
      - FLASK_RUN_PORT=8080
      # Use the HOST_IP_OR_DOMAIN variable for external URLs
      - AUTH_SERVICE_LOGIN_URL=https://${HOST_IP_OR_DOMAIN}/auth/
      - EVENT_SERVICE_URL=https://${HOST_IP_OR_DOMAIN}/events/
      # Also pass the actual domain to frontend for image URLs etc. if needed
      - HOST_IP_OR_DOMAIN=${HOST_IP_OR_DOMAIN}
    networks:
      - app-network

  db_api:
    build: ./app_db
    container_name: db_api_container
    restart: unless-stopped
    volumes:
      - db_data:/app/data
    networks:
      - app-network

  auth_api:
    build: ./Auth_Serv
    container_name: auth_api_container
    restart: unless-stopped
    environment:
      - DB_API_URL=http://db_api:5004 # Internal Docker network URL
      - FLASK_SECRET_KEY=test12
      - FLASK_SCRIPT_NAME=/auth
      # Use the HOST_IP_OR_DOMAIN variable for external portal URLs
      - USER_PORTAL_URL=https://${HOST_IP_OR_DOMAIN}/user-portal
      - ADMIN_PORTAL_URL=https://${HOST_IP_OR_DOMAIN}/admin-portal
      # For Auth Service Startup Admin provisioning (ensure these are set in your .env or build process)
      - DEFAULT_ADMIN_USERNAME=admin_nacs
      - DEFAULT_ADMIN_PASSWORD=adminpass # CHANGE THIS FOR PRODUCTION
      - DEFAULT_ADMIN_EMAIL=admin@example.com
      - DEFAULT_ADMIN_PHONE=9998887770
    depends_on:
      - db_api
    networks:
      - app-network
  
  event-service:
    build:
      context: ./Event_MS
    container_name: event_service_container
    restart: unless-stopped
    environment:
      - FLASK_RUN_PORT=5000
      - FLASK_SCRIPT_NAME=/events
      # Pass domain for static file URLs if constructed in Flask
      - HOST_IP_OR_DOMAIN=${HOST_IP_OR_DOMAIN}
    volumes:
      - event_db_data:/app/data
    networks:
      - app-network

  user-portal-service:
    build:
      context: ./User_portal_service
    container_name: user_portal_container
    restart: unless-stopped
    environment:
      - FLASK_RUN_PORT=5001
      - FLASK_SCRIPT_NAME=/user-portal
      - DB_API_URL=http://db_api:5004
      - EVENT_SERVICE_URL=http://event-service:5000
      - AUTH_SERVICE_URL=https://${HOST_IP_OR_DOMAIN}/auth
      - ERS_LANDING_PAGE_URL=https://${HOST_IP_OR_DOMAIN}/ers
      # Pass domain for proper URL generation
      - HOST_IP_OR_DOMAIN=${HOST_IP_OR_DOMAIN}
    depends_on:
      - db_api
      - event-service
      - auth_api
    networks:
      - app-network

  participation-service:
      build:
        context: ./participation_serv
      container_name: participation_service_container
      restart: unless-stopped
      environment:
        - FLASK_RUN_PORT=5005
        - FLASK_SCRIPT_NAME=/participations
      volumes:
        - participation_db_data:/app/data
      networks:
        - app-network

  ers-service:
    build:
      context: ./ERS_Serv
    container_name: ers_service_container
    restart: unless-stopped
    environment:
      - FLASK_RUN_PORT=5007
      - FLASK_SCRIPT_NAME=/ers
      - DB_API_URL=http://db_api:5004
      - EVENT_SERVICE_URL=http://event-service:5000
      - PARTICIPATION_SERVICE_URL=http://participation-service:5005
      - USER_PORTAL_ROOT_URL=https://${HOST_IP_OR_DOMAIN}/user-portal
      - HOST_IP_OR_DOMAIN=${HOST_IP_OR_DOMAIN}
    depends_on:
      - db_api
      - event-service
      - participation-service
    networks:
      - app-network

  admin-portal-service:
    build:
      context: ./Admin_Portal_Service
    container_name: admin_portal_container
    restart: unless-stopped
    environment:
      - FLASK_RUN_PORT=5006
      - FLASK_SCRIPT_NAME=/admin-portal
      - EVENT_SERVICE_URL=http://event-service:5000
      - AUTH_SERVICE_URL=http://auth_api:5002
      - PARTICIPATION_SERVICE_URL=http://participation-service:5005
      - DB_API_URL=http://db_api:5004
      - AUTH_SERVICE_EXTERNAL_URL=https://${HOST_IP_OR_DOMAIN}/auth
      - USER_PORTAL_EXTERNAL_URL=https://${HOST_IP_OR_DOMAIN}/user-portal
      - HOST_IP_OR_DOMAIN=${HOST_IP_OR_DOMAIN}
    depends_on:
      - event-service
      - auth_api
      - participation-service
    networks:
      - app-network

volumes:
  db_data:
  event_db_data:
  participation_db_data:
  # NEW: Volumes for Certbot to store webroot files and certificates
  certbot-web: # Used for HTTP-01 challenges
  certbot-certs: # Used for storing obtained certificates

networks:
  app-network:
    driver: bridge