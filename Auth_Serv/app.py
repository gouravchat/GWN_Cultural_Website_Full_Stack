import os
import requests
from flask import Flask, request, jsonify, render_template, send_from_directory, redirect, session, url_for
from bcrypt import hashpw, gensalt, checkpw
from flask_cors import CORS
import logging
import time

# Get the script name from environment variable, which Nginx will pass
# If not present, default to empty string for local direct access
AUTH_SERVICE_SCRIPT_NAME = os.environ.get('FLASK_SCRIPT_NAME', '')

# Initialize Flask app, setting static_url_path to include the SCRIPT_NAME if defined.
# This ensures that Flask's default static route automatically includes the prefix.
app = Flask(__name__,
            static_url_path=AUTH_SERVICE_SCRIPT_NAME + '/static',
            static_folder='static')

CORS(app)  # Enable CORS for all routes

# --- Configuration ---
app.secret_key = os.environ.get('FLASK_SECRET_KEY', 'your_default_very_secret_key_here_change_me_for_auth_serv')

DB_API_URL = os.environ.get('DB_API_URL', 'http://localhost:5004')

# Define redirect URLs. These should ideally come from environment variables.
USER_PORTAL_URL_AFTER_LOGIN = os.environ.get('USER_PORTAL_URL', 'https://localhost/user-portal') # e.g., https://your-domain.com/user-portal
ADMIN_PORTAL_URL_AFTER_LOGIN = os.environ.get('ADMIN_PORTAL_URL', 'https://localhost/admin-portal') # e.g., https://your-domain.com/admin-portal

# --- Crucial: Set APPLICATION_ROOT and SCRIPT_NAME for Nginx proxying ---
# APPLICATION_ROOT tells Flask about the external path it's served under.
app.config['APPLICATION_ROOT'] = AUTH_SERVICE_SCRIPT_NAME

# app logger configuration
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
app_logger = logging.getLogger(__name__)

#Admin password and user details for default admin creation
DEFAULT_ADMIN_USERNAME = os.environ.get('DEFAULT_ADMIN_USERNAME', 'admin_nacs') # Default admin username
DEFAULT_ADMIN_PASSWORD = os.environ.get('DEFAULT_ADMIN_PASSWORD', 'nestadmin@1234')   # Default admin password (CHANGE THIS IN PRODUCTION)
DEFAULT_ADMIN_EMAIL = os.environ.get('DEFAULT_ADMIN_EMAIL', 'Nest.alpine.cultural.team@gmail.com')
DEFAULT_ADMIN_PHONE = os.environ.get('DEFAULT_ADMIN_PHONE', '9933735742')

# This hook ensures that Flask's url_for generates correct URLs and
# request.path/request.url are correctly interpreted when behind a proxy.
@app.before_request
def set_script_name_from_proxy():
    # If Nginx sends X-Forwarded-Prefix, use that as the SCRIPT_NAME
    # This makes the Flask app aware of the external path prefix it's served under.
    if 'X-Forwarded-Prefix' in request.headers:
        request.environ['SCRIPT_NAME'] = request.headers['X-Forwarded-Prefix']
    # If not proxied, but FLASK_SCRIPT_NAME env var is set, use that
    elif AUTH_SERVICE_SCRIPT_NAME:
        request.environ['SCRIPT_NAME'] = AUTH_SERVICE_SCRIPT_NAME
    # Otherwise (direct access, no env var), SCRIPT_NAME is empty
    else:
        request.environ['SCRIPT_NAME'] = ''

# --- Routes for Frontend (Login/Registration Page) ---
@app.route('/')
def login_or_register_page():
    """Serves the login/registration page (index.html for Auth_Serv)."""
    target_portal = request.args.get('target')
    # Use url_for for static assets and ensure links are correctly generated by Flask
    return render_template('index.html', target_portal=target_portal) 

@app.route('/login', methods=['GET'])
def login_page():
    """Serves the login page."""
    target_portal = request.args.get('target')
    return render_template('index.html', target_portal=target_portal) 

# The /static/<path:filename> route is now typically handled automatically by Flask
# when static_url_path is set in app = Flask(...) and url_for('static', ...) is used.
# You can remove this explicit route if you only rely on Flask's default static handling.
# However, keeping it for explicit control is also fine, but ensure it's compatible
# with the SCRIPT_NAME and static_url_path configuration.
# @app.route(f'{AUTH_SERVICE_SCRIPT_NAME}/static/<path:filename>') # This route definition path might need adjustment if using SCRIPT_NAME.
# The default Flask behavior is often enough. Let's rely on that first.
# If you keep this route, ensure 'static_folder' is correctly mapped, and it's relative to the app.py location.
@app.route('/static/<path:filename>')
def serve_auth_static(filename):
    """Serves static files (CSS, JS) for the Auth_Serv's login/registration page."""
    # This path is relative to the static_folder specified in Flask(__name__, static_folder='static')
    # With SCRIPT_NAME, Flask's url_for('static', 'style.css') will generate /auth/static/style.css
    # and this route will correctly handle /static/style.css internally after Nginx strips the prefix.
    return send_from_directory(app.static_folder, filename)

# --- End Routes ---


@app.route('/login', methods=['POST'])
def login():
    data = request.get_json()
    identifier = data.get('identifier')
    password = data.get('password')

    if not identifier or not password:
        return jsonify({"error": "Identifier (username/email/phone) and password are required."}), 400

    try:
        db_response = requests.get(f"{DB_API_URL}/users", params={'query': identifier})
        db_response.raise_for_status()
        user_data_response = db_response.json()

        user = None
        if isinstance(user_data_response, list):
            for u_data in user_data_response:
                if (u_data.get('username') == identifier or
                    u_data.get('email') == identifier or
                    u_data.get('phone_number') == identifier):
                    user = u_data
                    break
        elif isinstance(user_data_response, dict) and user_data_response.get("id"):
            if (user_data_response.get('username') == identifier or
                user_data_response.get('email') == identifier or
                user_data_response.get('phone_number') == identifier):
                user = user_data_response
        elif isinstance(user_data_response, dict) and user_data_response.get("message") == "User not found.":
            return jsonify({"error": "Invalid credentials."}), 401


        if not user or 'hashed_password' not in user:
            return jsonify({"error": "Invalid credentials or user data issue."}), 401

        if checkpw(password.encode('utf-8'), user['hashed_password'].encode('utf-8')):
            session['user_id'] = user['id']
            session['username'] = user['username']
            session['role'] = user.get('role', 'user')
            session.permanent = True

            redirect_url = ""
            if user.get('role') == 'admin':
                # Admin Portal URL does not need user ID typically for its root page
                # Ensure this is constructed with url_for if it's an internal route
                redirect_url = ADMIN_PORTAL_URL_AFTER_LOGIN
            else:
                # User Portal URL needs user ID as path parameter: http://localhost:5001/portal/123
                base_user_portal_url = USER_PORTAL_URL_AFTER_LOGIN.rstrip('/')
                redirect_url = f"{base_user_portal_url}/portal/{user['id']}"

            app.logger.info(f"Login successful for {user['username']}. Role: {user.get('role')}. Redirecting to: {redirect_url}")

            return jsonify({
                "message": "Login successful",
                "user_id": user['id'],
                "username": user['username'],
                "role": user.get('role', 'user'),
                "redirect_url": redirect_url
            }), 200
        else:
            return jsonify({"error": "Invalid credentials."}), 401

    except requests.exceptions.ConnectionError:
        app.logger.error("Failed to connect to DB API during login.")
        return jsonify({"error": "Login service is temporarily unavailable (DB API connection error)."}), 503
    except requests.exceptions.Timeout:
        app.logger.error("DB API connection timed out during login.")
        return jsonify({"error": "Login service is temporarily unavailable (DB API timeout)."}), 504
    except requests.exceptions.RequestException as e:
        status_code = e.response.status_code if e.response is not None else 500
        app.logger.error(f"Error communicating with DB API during login: {e} (Status: {status_code})")
        error_details = "Error during DB API communication"
        if e.response is not None:
            try:
                error_details_from_db = e.response.json().get('error', str(e))
                error_details = f"DB API Error: {error_details_from_db}"
            except ValueError:
                error_details = f"DB API Error: {e.response.text}"
        return jsonify({"error": error_details}), status_code
    except Exception as e:
        app.logger.error(f"An unexpected error occurred during login: {e}")
        return jsonify({"error": "An internal server error occurred during login."}), 500


@app.route('/register', methods=['POST'])
def register_user():
    data = request.get_json()
    username = data.get('username')
    email = data.get('email')
    phone_number = data.get('phone_number')
    password = data.get('password')

    if not all([username, email, phone_number, password]):
        return jsonify({"error": "All fields are required."}), 400
    
    if not "@" in email:
        return jsonify({"error": "Invalid email format."}), 400
    
    hashed_password = hashpw(password.encode('utf-8'), gensalt()).decode('utf-8')
    new_user_data = {
        "username": username,
        "email": email,
        "phone_number": phone_number,
        "hashed_password": hashed_password,
        "role": "user"
    }

    try:
        db_response = requests.post(f"{DB_API_URL}/users", json=new_user_data)
        db_response.raise_for_status()
        created_user = db_response.json()
        
        session['user_id'] = created_user['id']
        session['username'] = created_user['username']
        session['role'] = created_user.get('role', 'user')
        session.permanent = True

        # Redirect new users to their portal page
        base_user_portal_url = USER_PORTAL_URL_AFTER_LOGIN.rstrip('/')
        registration_redirect_url = f"{base_user_portal_url}/portal/{created_user['id']}"

        return jsonify({
            "message": "User registered successfully. You are now logged in.",
            "user": created_user,
            "redirect_url": registration_redirect_url
        }), 201

    except requests.exceptions.ConnectionError:
        app.logger.error("Failed to connect to DB API during registration.")
        return jsonify({"error": "Registration service is temporarily unavailable (DB API connection error)."}), 503
    except requests.exceptions.Timeout:
        app.logger.error("DB API connection timed out during registration.")
        return jsonify({"error": "Registration service is temporarily unavailable (DB API timeout)."}), 504
    except requests.exceptions.RequestException as e:
        status_code = e.response.status_code if e.response is not None else 500
        app.logger.error(f"Error communicating with DB API during registration: {e} (Status: {status_code})")
        error_details = "Error during DB API communication for registration"
        if e.response is not None:
            try:
                error_details_from_db = e.response.json().get('error', str(e))
                if status_code == 409:
                     return jsonify({"error": error_details_from_db or "User with these details already exists."}), 409
                error_details = f"DB API Error: {error_details_from_db}"
            except ValueError:
                error_details = f"DB API Error: {e.response.text}"
        return jsonify({"error": error_details}), status_code
    except Exception as e:
        app.logger.error(f"An unexpected error occurred during registration: {e}")
        return jsonify({"error": "An internal server error occurred during registration."}), 500

@app.route('/logout', methods=['POST'])
def logout():
    session.clear()
    # Redirect to the Auth Service's own login page after logout
    # Ensure url_for generates a path relative to SCRIPT_NAME
    return jsonify({"message": "Logout successful", "redirect_url": url_for('login_or_register_page', _external=False)}), 200


@app.route('/hash_password', methods=['POST'])
def hash_password_endpoint():
    data = request.get_json()
    password = data.get('password')
    if not password:
        return jsonify({"error": "Password is required."}), 400
    hashed = hashpw(password.encode('utf-8'), gensalt())
    return jsonify({"hashed_password": hashed.decode('utf-8')}), 200


# --- NEW: Function to create default admin user on startup ---
# --- Admin User Creation Logic ---
# This function is now a standalone helper.
# It includes a retry mechanism for robustness during startup.
def provision_admin_user_on_startup(app_instance):
    """
    Attempts to create a default admin user in the DB API if one doesn't exist.
    This function includes retries for DB_API connectivity, as it's meant to run
    at service startup where DB_API might not be immediately available.
    """
    app_logger.info("Auth Service startup: Starting admin provisioning logic with retries.")
    
    admin_username = DEFAULT_ADMIN_USERNAME
    admin_password = DEFAULT_ADMIN_PASSWORD
    admin_email = DEFAULT_ADMIN_EMAIL
    admin_phone = DEFAULT_ADMIN_PHONE

    if not all([admin_username, admin_password, admin_email, admin_phone]):
        app_logger.error("Missing environment variables for DEFAULT_ADMIN_USERNAME, DEFAULT_ADMIN_PASSWORD, etc. Cannot provision default admin.")
        return

    max_retries = 15 # Increased retries
    retry_delay_seconds = 5 # Increased delay

    for attempt in range(max_retries):
        try:
            app_logger.info(f"Attempt {attempt + 1}/{max_retries}: Checking for admin user '{admin_username}' in DB API...")
            check_response = requests.get(f"{DB_API_URL}/users", params={'query': admin_username}, timeout=5)
            
            user_found_in_db = False
            if check_response.status_code == 200:
                user_data_response = check_response.json()
                if isinstance(user_data_response, list) and any(u.get('username') == admin_username for u in user_data_response):
                    user_found_in_db = True
                elif isinstance(user_data_response, dict) and user_data_response.get('username') == admin_username:
                    user_found_in_db = True
                else:
                    app_logger.debug(f"DB API returned data for query '{admin_username}' but no matching user found in content (status 200).")
            elif check_response.status_code == 404:
                app_logger.info(f"Default admin user '{admin_username}' not found (DB API returned 404). Proceeding to create.")
            else:
                app_logger.error(f"Failed to check for admin user existence (Status: {check_response.status_code}): {check_response.text}")
                # If cannot check, retry (as it might be a temporary DB API issue)
                raise requests.exceptions.RequestException(f"Failed initial check (status {check_response.status_code})")

            if user_found_in_db:
                app_logger.info(f"Default admin user '{admin_username}' already exists in DB API. Skipping creation.")
                return # Exit successfully

            # 2. If admin user doesn't exist, create it
            hashed_password = hashpw(admin_password.encode('utf-8'), gensalt()).decode('utf-8')
            admin_user_data = {
                "username": admin_username,
                "email": admin_email,
                "phone_number": admin_phone,
                "hashed_password": hashed_password,
                "role": "admin"
            }

            app_logger.info(f"Attempting to create default admin user '{admin_username}' in DB API.")
            create_response = requests.post(f"{DB_API_URL}/users", json=admin_user_data, timeout=5)
            create_response.raise_for_status()
            
            app_logger.info(f"Default admin user '{admin_username}' created successfully in DB API.")
            return # Exit successfully after creation
        
        except requests.exceptions.ConnectionError:
            app_logger.warning(f"Could not connect to DB API at '{DB_API_URL}' (attempt {attempt + 1}). Retrying in {retry_delay_seconds}s...")
        except requests.exceptions.Timeout:
            app_logger.warning(f"DB API connection timed out at '{DB_API_URL}' (attempt {attempt + 1}). Retrying in {retry_delay_seconds}s...")
        except requests.exceptions.RequestException as e:
            response_text = e.response.text if e.response else 'N/A'
            status_code = e.response.status_code if e.response is not None else 500
            app_logger.warning(f"Error during admin user creation (attempt {attempt + 1}): {e} (Status: {status_code}). Response: {response_text}. Retrying in {retry_delay_seconds}s...")
            if status_code == 409: # Conflict means user exists, so it's not an error that needs retry
                app_logger.info(f"Admin creation failed due to conflict (user might have been created by another process or concurrent startup). Skipping further retries for creation.")
                return # Exit successfully if user already exists
        except Exception as e:
            app_logger.critical(f"An unexpected error occurred during default admin provisioning on startup (attempt {attempt + 1}): {e}", exc_info=True)
            # For unhandled critical errors, re-raise if max retries hit, or log and retry.
        
        if attempt < max_retries - 1:
            time.sleep(retry_delay_seconds)
        else:
            app_logger.critical(f"Max retries ({max_retries}) reached. Failed to provision default admin user '{admin_username}'. This service might not function correctly if admin is required.")


if __name__ == '__main__':
    # This block runs ONLY when the script is executed directly (e.g., `python app.py`).
    # It does NOT run when Gunicorn (or other WSGI servers) imports the `app` object.
    # We need to call the admin provisioning logic here.
    # It must run within an app context if it needs to access app.config, etc.
    # For this specific case, as it uses requests and logging, it doesn't strictly need
    # app.app_context() if it's external calls. But it's good practice for Flask-related startup.
    #with app.app_context(): # Provide app context for safety and consistency
    provision_admin_user_on_startup(app)   
    # Run the Flask development server
    app.run(host='0.0.0.0', port=5002, debug=True)